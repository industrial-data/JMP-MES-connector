/***********************************************************
 * General Information
 *
 * Script Title    : Ressources UTILITIES
 * Version         : 2.0
 *
 * Description:
 * This script provides utility functions and resources for various purposes.
 * It includes functions for data processing, visualization, and analysis.
 *
 * Usage:
 * - Import and run this script in JMP to make the utility functions available.
 *
 * For more information, refer to the function documentation within this script.
 ************************************************************/

/***********************************************************
 *                SCRIPT TABLE OF CONTENTS
 ************************************************************/

/****************************************************
 *  I. UTILITIES FOR ERROR MESSAGES
 *  II. UTILITIES FOR TEXT PROCESSING
 *  III. UTILITIES FOR TAG EXTRACTION AND ANALYSIS
 *  IV. UTILITIES FOR GUARDBAND CHART
 *  V. OTHER UTILITIES
 *  VI. COMMUN BUTTONS FOR ATTACHED SCRIPTS
 ****************************************************/


/****************************************************
*  I. UTILITIES FOR ERROR MESSAGES
******************************************************/

/*
    f_log Function
        
    This function allows for the printing of log messages with a specified prefix indicating the severity or type
    of each log message, along with an associated message and section code.
    
    @param Prefix: The prefix indicating the severity or type of the log message (e.g., "INFO:", "WARNING:", "ERROR:").
    @param strMessage: The message to display (character).
    @param section: The code part concerned (e.g., [PREVIEW]).
*/

f_Log = Function( {Prefix, strMessage, section = ""},
	{Default Local}, 

	nbIntend = Match( Char( Prefix ), "INFO", 8, "WARNING", 5, "ERROR", 7 );

	Intend = ":" || Repeat( " ", nbIntend );

	If( section == "",
		Print( Char( Prefix ) || Intend || Char( strMessage ) ),
		Print( Char( Prefix ) || Intend || "[" || section || "] " || Char( strMessage ) )
	);
);


/*
    f_DialogError Function
        
    This function opens a new window to display an error message provided as input.
    
    @param strError: The error message to display (character).
*/
f_DialogError = Function( {strError},
	{Default Local}, 

	// Center the  Window
	ErrorSizeX = 400;
	ErrorSizeY = 100;
	XPos = (WindowSize[1] - ErrorSizeX) / 2;
	YPos = (WindowSize[2] - ErrorSizeY) / 2;	
	
	// Reset buttons
	f_ResetButtons;
	
	f_Log( "ERROR", strError );
	New Window( "Error",
		<<modal,
		<<Size( ErrorSizeX, ErrorSizeY ),
		<<OnOpen( Window( "Error" ) << moveWindow( XPos, YPos ) ),
		Text Box( Char( strError ), <<Set Wrap( 400 ) ),
		Spacer Box( size( 15, 15 ), <<set max size( 400, 15 ), <<set auto stretching( 1, 1 ) ),
		H Center Box( Button Box( "OK" ) )
	);
	

	
	Throw();
);


/*
    f_DialogWarning Function
        
    This function opens a new window to display a warning message provided as input.
    
    @param strWarning: The warning message to display (character).
*/
f_DialogWarning = Function( {strWarning},
	{Default Local}, 

	// Center the  Window
	ErrorSizeX = 400;
	ErrorSizeY = 100;
	XPos = (WindowSize[1] - ErrorSizeX) / 2;
	YPos = (WindowSize[2] - ErrorSizeY) / 2;	
	
	
	f_Log( "WARNING", strWarning );
	New Window( "Warning",
		<<modal,
		<<Size( ErrorSizeX, ErrorSizeY ),
		<<OnOpen( Window( "Warning" ) << moveWindow( XPos, YPos ) ),
		V List Box(
			Text Box( Char( strWarning ), <<Set Wrap( 400 ) ),
			Spacer Box( size( 15, 15 ), <<set max size( 400, 15 ), <<set auto stretching( 1, 1 ) ),
			H Center Box( Button Box( "OK" ) )
		)
	);

	
);

/*
    f_ResetButtons Function
        
    This function reset buttons in UI in case of errors
    
*/
f_ResetButtons = Function( {},
	Try( bttn_Extraction << Set Button Name( "Run extraction" ) );
	Try( bttn_Extraction << enabled( 1 ) );
	Try( bttn_Extraction2 << enabled( 1 ) );
	Try( bttn_Extraction2 << Set Button Name( "Run extraction" ) );
	Try( bttn_AddTags << enabled( 1 ) );
	Try( bttn_AddTags << Set Button Name( "Add tags" ) );
	Try( progress:term() );
	
);

/****************************************************
*  II. UTILITIES FOR TEXT PROCESSING
******************************************************/

/**
	f_RemoveDuplicates - A function to remove duplicates from a list.

	This function takes an input list and returns a new list containing only the unique elements
	from the input list, removing any duplicates. It does so by iterating through the input list,
	checking for duplicate items, and creating a new list with unique elements.
	
	@param InputList: The list from which duplicates should be removed.
	@return UniqueList: A list containing only the unique elements from InputList.
 
 */
f_RemoveDuplicates = Function( {InputList},
	{Default Local Variables},
	UniqueList = {};  // Initialize an empty list to store unique elements

	// Loop through the input list
	For Each( {value, index}, InputList, 
										
		If( !Contains( UniqueList, value ),
			Insert Into( UniqueList, value )
		)
										
	);

	Return( UniqueList );  // Return the list with duplicates removed
);
/*
    f_Remove_UnitDescription Function
        
    This function is used to remove descriptions and units from a single tag name or a list of tag names.
    It takes the tag name(s) and an associative array that contain descriptions and units for the tag(s),
    and returns the tag name(s) without descriptions and units.
    
    @param Tag: Either a tag name or a list of tag names.
    @param Tag_AA: Associative array with and without unit/description for the tag(s).
    
    @return: The tag name or list of tag names without descriptions and units.
*/

f_Remove_UnitDescription = Function( {Tag, Tag_AA},
	{Default Local}, 

	If( Is List( Tag ), 
	
		CleanTag = List();
	
		For( l = 1, l <= N Items( Tag ), l++, 
		
			Tag_NoType = f_RemoveSuffixFromWord( Tag[l], AllTypes );
			Try( TagAdded = Tag_AA[Tag_NoType], TagAdded = Tag_NoType );
			
			Insert Into( CleanTag, TagAdded )
			
			;
		);
		
	, 
		// Only one tagname
		Tag_NoType = f_RemoveSuffixFromWord( Tag, AllTypes );
		Try( TagAdded = Tag_AA[Tag_NoType], TagAdded = Tag_NoType );
		CleanTag = TagAdded;
	);
	
	Return( CleanTag );
);

/*
    f_Remove_SpecialCharacters Function
        
    This function takes a word and removes any special characters that are not allowed in Windows or Linux path directories.
    The cleaned word can be used as a filename or directory name.
    
    @param Word: The input word containing special characters.
    
    @return: The cleaned word with special characters removed.
*/
f_Remove_SpecialCharacters = Function( {Word},
	{Default Local}, 
    
    
    // Remove forbidden characters from the word
	CleanWord = Substitute( Word, ":", "_", "\", "_", "/", "_", "*", "_", "?", "_", "\!"", "_", "<", "_", ">", "_", "|", "_" ); 
    
	Return( CleanWord );
);



/*
    f_SQL_query_to_line Function
    
    
    This function takes an SQL query string as input and formats it to be in a single line. It replaces tab and carriage return characters with spaces to ensure that the SQL command is on one line.
    
    @param SQL_Query: The SQL query to be formatted (character).
    
    @return: The formatted SQL query as a single-line string.
*/
f_SQL_query_to_line = Function( {SQL_Query},
	{Default Local},
	SQL_query = Substitute( SQL_query, "\!t", " " );
	SQL_query = Substitute( SQL_query, "\!r", " " );
	Return( SQL_Query );
);


/*
    f_CheckStringEnding Function
    
    
    This function takes a string and a list of suffixes as input and checks if the string ends with any of the specified suffixes within the list enclosed in curly braces { }. If a matching suffix is found, it is returned; otherwise, 0 is returned.
    
    @param str: The string to check (character).
    
    @param suffixList: The list of suffixes to check between curly braces { } (list of characters).
    
    @result: The matching suffix found or 0 if none match.
*/
f_CheckStringEnding = Function( {str, suffixList},
	{Defaut Local}, 
    // Loop through the suffix list
	For( i = 1, i <= N Items( suffixList ), i++, 
        // Get the current suffix from the list
		currentSuffix = suffixList[i];

		If( Ends With( str, "{" || currentSuffix || "}" ),
			Return( currentSuffix )
		);
	);
    // If no match is found with any of the suffixes, return 0
	Return( 0 ); // No match found
);

/*
    f_ReorderAssociativeArray Function
    
    
    This function takes an associative array and a key as input, removes the specified key from the associative array, and reorders the remaining keys. The result is a new associative array with the keys reordered.
    
    @param InputAssocArray: The input associative array (associative array).
    
    @param KeyToDelete: The key to remove from the associative array (any type).
    
    @result: A new associative array with keys reordered.
*/
f_ReorderAssociativeArray = Function( {InputAssocArray, KeyToDelete},
	{Default Local},
	NewAssocArray = Associative Array(); // Crée une nouvelle associative array
	Remove From( InputAssocArray, KeyToDelete );
	InputAssocArray_KEYS = InputAssocArray << Get Keys();
	NewKey = 1; 
    
    // Parcourez les clés de l'association d'entrée
	For( i = 1, i <= N Items( InputAssocArray_KEYS ), i++,
		Key = InputAssocArray_KEYS[i];
		NewAssocArray[NewKey] = InputAssocArray[Key];
		NewKey++;
	);
    
	Return( NewAssocArray );
);


/*
    f_NestFilters Function
    
    
    This function takes an associative array, a list of keys to nest, and an identifier for the next nesting level as input. It removes the specified keys from the associative array and nests their values under a new key. The result is a modified associative array with nested values.
    
    @param InputAssocArray: The input associative array (associative array).
    
    @param KeysToNest: The list of keys to nest (list of any type).
    
    @param NextID: The identifier for the next nesting level (any type).
    
    @result: A modified associative array with nested values.
*/
f_NestFilters = Function( {InputAssocArray, KeysToNest, NextID},
	{Default Local}, 
	
	NestedTags = {};
	NestedType = {};
	NestedFilters = {};
	
	For( i = 1, i <= N Items( KeysToNest ), i++,
		Key = KeysToNest[i];
		Insert Into( NestedTags, InputAssocArray[Key][1] );
		Insert Into( NestedType, InputAssocArray[Key][2] );
		Insert Into( NestedFilters, InputAssocArray[Key][3] );
	);
	
	Eval( Eval Expr( InputAssocArray[NextID] = {Expr( NestedTags ), Expr( NestedType ), Expr( NestedFilters )} ) );
	
	Return( InputAssocArray );
);


/*
    f_RemoveSuffixFromWord Function
    
    This function takes a word and a list of suffixes as parameters and checks if the word
    ends with any of the specified suffixes. If a matching suffix is found, it is removed
    from the word, and the resulting word is returned.

    Parameters:
        - word (string): The word to process.
        - suffixList (list of strings): The list of suffixes to check.

    Returns:
        - string: The resulting word after removing the suffix (if found).
*/

f_RemoveSuffixFromWord = Function( {word, suffixList},
	{Default Local}, 
    
    // Loop through the list of suffixes
	For( i = 1, i <= N Items( suffixList ), i++, 
        
        // Get the current suffix
		suffix = " {" || suffixList[i] || "}";
        
        // Check if the word ends with the current suffix
		If( Right( word, Length( suffix ) ) == suffix, 
            
            // If yes, remove the suffix from the word
			word = Left( word, Length( word ) - Length( suffix ) );
            
            // Exit the loop because a suffix has been found
			Break();
		);
	);
    
    // Return the resulting word
	Return( word );
);


/*
	Function: f_RemoveQuotesIfWrapped

	Description:
	This function takes a list of items as input, checks each item in the list, and removes simple quotes if they wrap the value. If an item is not wrapped in simple quotes, it returns the item as it is.

	Parameters:
	- List (List of Characters): A list of items that may or may not be enclosed in single quotes.

	Returns:
	(List of Characters): A new list with quotes removed from values that are enclosed in single quotes, while leaving unquoted values unchanged.

*/
f_RemoveQuotesIfWrapped = Function( {List},
	{Default Local}, 
    
	result = List();
    
	If( Is List( List ),
		For Each( {value, index}, List,
			itemStr = Char( value ); // Convert the item to a string

			// Check if the item is enclosed in single quotes
			If( And( Starts With( itemStr, "'" ), Ends With( itemStr, "'" ) ), 
            // Remove the quotes if the item is wrapped in single quotes
				cleanedItem = Substr( itemStr, 2, Length( itemStr ) - 2 )
			, 
            // Leave the item unchanged if it's not wrapped in quotes
				cleanedItem = itemStr
			);

			cleanedItem = Char( cleanedItem ); // Convert back to char
			Insert Into( result, cleanedItem ); // Add cleaned item to the result list
		);
	
	,
		If( And( Starts With( List, "'" ), Ends With( List, "'" ) ), 
            // Remove the quotes if the item is wrapped in single quotes
			result = Substr( List, 2, Length( List ) - 2 )
		, 
            // Leave the item unchanged if it's not wrapped in quotes
			result = List
		);	 
	
	);
	Return( result );
);


/*
	Function: f_AreListsDifferent

	Description:
	This function takes two lists of items as input, checks if each items in the list1 is in list 2.

	Parameters:
	- List1 (List of Characters): A list of items.
	- List2 (List of Characters): A list of items.

	Returns:
	1 if list1 and list2 are different , 0 otherwise.

*/
f_AreListsDifferent = Function( {List1, List2},
	{Default Local}, 
     
	If( N Items( List1 ) != N Items( List2 ),
		Return( 1 )
	);
	For Each( {value, index}, List1, If( Char( List2[index] ) != Char( value ), Return( 1 ) ) );
	Return( 0 );
);

/*
	Function: f_Convert2ListFilters

	This function converts a set of filters into a list of filter expressions. It processes the Filters_AA argument, which is expected to be a list of filter definitions, and combines them using the specified logical condition (AND or OR).

	Parameters:
	- Filters_AA (List of Tuples): A list of filter definitions. Each filter definition is represented as a tuple containing key and value.
	- Condition (String): The logical condition used to combine the filter expressions. Should be either "AND" or "OR".

	Returns:
	- List: A list of filter expressions as strings, combined according to the specified logical condition.

	Note:
	- The function supports both nested and non-nested filter definitions and correctly combines them based on the specified logical condition.
*/
f_Convert2ListFilters = Function( {Filters_AA, Condition},
	{Default Local}, 
    
	LstFilters = List();
	strNestCondition = Match( Condition, "AND", "OR", "OR", "AND" );
    
	For Each( {{key, value}, index}, Filters_AA, 
		
		If( Is List( value[1] ), 
		
			// Nested
			TagDescUnit1 = value[1][1];
			TagDescUnit2 = value[1][2];
			Comp1 = value[3][1];
			Value1 = value[3][2];
			Comp2 = value[3][3];
			Value2 = value[3][4];
			
			strFilter = "(" || Char( TagDescUnit1 ) || " " || Char( Comp1 ) || " " || Char( Value1 ) || ")  " || strNestCondition || "  (" ||
			Char( TagDescUnit2 ) || " " || Char( Comp2 ) || " " || Char( Value2 ) || ")";
		, 
			
			// Not Nested
			
			TagDescUnit = value[1];
			Comp = value[3][1];
			Value = value[3][2];
			
			strFilter = Char( TagDescUnit ) || " " || Char( Comp ) || " " || Char( Value );
			
		);
		
		Insert Into( LstFilters, strFilter );
	);
    
    // Return the resulting word
	Return( LstFilters );
);

/*
	Function: f_CleanFiltersAA

	This function processes a list of filter definitions and converts them into a list of filter expressions. 

	Parameters:
	- Filters_AA (List of Tuples): A list of filter definitions. Each filter definition is represented as a tuple containing key and value.
	- TagSelect_AA (List of Tuples): A list with correspondance between tagnames with and without unit/description/type.

	Notes:
	- This function supports both nested and non-nested filter definitions and correctly combines them based on the specified logical condition.

	Modification Details:
	- The function cleans the filter definitions by removing any {Type} from the end of the tag names, making sure they match the available columns. If not, it handles missing columns and updates the filter definitions accordingly.

*/
f_CleanFiltersAA = Function( {Filters_AA, TagSelect_AA}, 

	If( N Items( Filters_AA ) > 0,
		For Each( {{key, value}, index}, Filters_AA, 
		
			TagName = value[1];

			If( Is List( TagName ), 
				
				/* NESTED FILTERS*/

				//Remove {Type} from the end of the tagname
				TagName_Cleaned1 = f_RemoveSuffixFromWord( TagName[1], AllTypes );
				If( TagName_Cleaned1 != TagName[1],
					Filters_AA[index][1][1] = TagName_Cleaned1
				);
				TagName_Cleaned2 = f_RemoveSuffixFromWord( TagName[2], AllTypes );
				If( TagName_Cleaned2 != TagName[2],
					Filters_AA[index][1][2] = TagName_Cleaned2
				);
				
				If( !(TagSelect_AA << Contains Item( TagName_Cleaned1 )),
					Filters_Changed = 1;
					Try(
						IDTag = As List( Loc( TagSelect_AA << Get values, TagName_Cleaned1 ) )[1];
						Filters_AA[index][1][1] = (TagSelect_AA << Get Keys)[IDTag];
					,
						f_DialogError( "Missing column(s) needed for filter(s): " || Char( TagName_Cleaned1 ) )
					);
				);
				If( !(TagSelect_AA << Contains Item( TagName_Cleaned2 )),
					Filters_Changed = 1;
					Try(
						IDTag = As List( Loc( TagSelect_AA << Get values, TagName_Cleaned2 ) )[1];
						Filters_AA[index][1][2] = (TagSelect_AA << Get Keys)[IDTag];
					,
						f_DialogError( "Missing column(s) needed for filter(s)" || Char( TagName_Cleaned2 ) )
					);
				);
			, 
				/* SIMPLE FILTER */

				//Remove {Type} from the end of the tagname
				TagName_Cleaned = f_RemoveSuffixFromWord( TagName, AllTypes );
				If( TagName_Cleaned != TagName,
					Filters_AA[index][1] = TagName_Cleaned
				);
				If( !(TagSelect_AA << Contains Item( TagName_Cleaned )),
					Filters_Changed = 1;
					Try(
						IDTag = As List( Loc( TagSelect_AA << Get values, TagName_Cleaned ) )[1];
						Filters_AA[index][1] = (TagSelect_AA << Get Keys)[IDTag];
					,
						f_DialogError( "Missing column(s) needed for filter(s)" || Char( TagName_Cleaned ) )
					);
				);
			);
		)
	);
	
	Return( Filters_AA );
);

/*
    f_newElementsNotInOldList Function

    This function finds and returns a list of new elements in the "New List" that do not exist in the "Old List."

    @param Old List: The list containing the old elements.
    @param New List: The list containing the new elements.

    @return: A list of new elements found in the "New List" but not present in the "Old List."
*/
f_newElementsNotInOldList = Function( {Old List, New List},
	{Default Local}, 
	
	NewElt = List();
	
	For( i = 1, i <= N Items( New List ), i++,
		item = New List[i];
		If( Contains( Old List, item ) == 0,
			Insert Into( NewElt, item )
		);
	);
	Return( NewElt );
);


/****************************************************
*  III. UTILITIES FOR TAG EXTRACTION AND ANALYSIS
******************************************************/


/*
    f_SetUp4Extraction Function
    
    
    This function configures extraction parameters based on the type of data server (IP21 or PI).
    
    @param ServerType: The type of data server (IP21 or PI).
    
    @return: None.
*/

f_SetUp4Extraction = Function( {ServerType}, 

	If( ServerType == "PI", 
	
	// PI - SET EXTRACT PARAMETERS -------------------------------------------------------------------
		
		Try(
			If( ExtractionMethod == "Actual",
				TablePI = "PICOMP";
				SQL_InterpolatedPI = "";
			
			,
				If( ExtractionMethod == "Interpolated",
					TablePI = "PIINTERP2";
					SQL_InterpolatedPI = "AND timestep = '" || Char( NewPeriodNumValue_s ) || "s'";
				,
					TablePI = "PIAVG";
					SQL_InterpolatedPI = "AND timestep = '" || Char( NewPeriodNumValue_s ) || "s'";
				)
			);
	
			f_Log(
				"INFO", "Extraction settings (PI Specific). TablePI " || Char( TablePI ) || " / SQL_InterpolatedPI " || Char( SQL_InterpolatedPI )
			);
		);
		
	// PI - CHECK POWERSHELL -------------------------------------------------------------------
	
		If( Not( File Exists( ps_path ) ),
			f_Log( "WARNING", "Powershell Script file not found. Creating at:  " || Char( ps_path ) );
			Save Text File( ps_path, SQL_OLEDB_PS );
		);
	
		PS_text = Load Text File( ps_path );

		ver_position = Contains( PS_text, "ver=" );
		// It should return position 3
		
		ps_version = Substr( PS_text, ver_position + 4, ver_position + 7 );
		f_Log( "INFO", "Powershell Version - " || Char( ps_version ) );

		If( Or( Not( ver_position == 3 ), Not( ps_version == ps_hard_code_version ) ),
			f_Log( "WARNING", "Creating newer PowerShell file with OLEDB extraction details." );
			Save Text File( ps_path, SQL_OLEDB_PS );
		);
	
	// PI - CHECK PI CONNECTOR -------------------------------------------------------------------
	
		get_command = "Get-PIDataArchiveConnectionConfiguration";
		f_Log( "INFO", "PI Server - Obtaining list of PI connections..." );
		
		get_result = Run Program(
			Executable( "powershell.exe" ),
			Options( {"/C", get_command} ),
			ReadFunction( "text" ) // returns all text	
		);
	
		connector_position = Contains( get_result, "ServerPath : " || Char( NetworkNode ) );
	
		If( connector_position == 0, 
	
		// If no connector found for the NetworkNode :
		
			add_command = "powershell \!"Add-PIDataArchiveConnectionConfiguration -Name '" || Char( ShortName ) || "' -Path '" || Char( NetworkNode )
			 || "'\!"";
		
			f_Log(
				"WARNING", "No connector found for the NetworkNode. Adding new PI connection (following MES Switcher convention) - " || add_command
			); 
		 
			add_result = Run Program(
				Executable( "cmd.exe" ),
				Options( {"/C", add_command} ),
				ReadFunction( "text" ) // returns all text	
			);
		,
			f_Log( "INFO", "Connector found for the NetworkNode." )
		);
	, 
	
	
	// IP21 - SET EXTRACT PARAMETERS -------------------------------------------------------------------
	
		Try(
		// Actual
			If( ExtractionMethod == "Actual",
				Request = "4";
				TableIP21 = "HISTORY(80)";
				ValueIP21 = "VALUE";
			
			, 
		//Interpolated
				If( ExtractionMethod == "Interpolated",
					Request = "6";
					TableIP21 = "HISTORY(80)";
					ValueIP21 = "VALUE";
				, 
		// Average
					Request = "1";
					TableIP21 = "AGGREGATES";
					ValueIP21 = "AVG";
			// 1 is the default and means that the statistics are time integrated. 0 means use raw data.
				)
			);
	
	// Display Extraction options in log
			f_Log(
				"INFO",
				"Extraction settings (IP21 Specific). Request " || Char( Request ) || " / Table " || Char( TableIP21 ) || " / Value " ||
				Char( ValueIP21 )
			);
		)
	)
);





/*
    f_Convert_In_PowershellScript Function
    
    
    This function executes an OLEDB query on a MES Server using PowerShell. It takes the PowerShell script path, MES Server, and SQL query as input parameters. The function returns the result of the query.
    
    @param ps_path: The path to the PowerShell script file (character).
    @param MES: The MES Server to connect to (character).
    @param SQL_query: The SQL query to be executed via PowerShell on the MES Server (character).
    
    @return: The result of the SQL query execution.
*/


f_Convert_In_PowershellScript = Function( {ps_path, MES, SQL_query},
	{Default local}, 
	
	
	command = "powershell -ExecutionPolicy Bypass -File " || ps_path || " " || MES || " \!"" || SQL_query || "\!"";
	
	f_Log( "INFO", "<SQL Query> (PI) \!n\!n" );

	Write( command );
		
	Print( "\!n\!n" );
	
	query_result = Run Program(
		Executable( "cmd.exe" ),
		Options( {"/C", command} ),
		ReadFunction( "blob" ) // returns all text	
	);
	
	Return( query_result );
);


/*
    f_FormatDates Function

    This function checks and adjusts date ranges to ensure that the number of data points retrieved from a server, based on the specified server type, does not exceed a defined limit. It also handles error checking and displays warnings when necessary.

    @param Start: The start date (numeric)
    @param End: The end date (numeric)
    @param UTCBool: Boolean (0/1). If the start/end are in localtime, UTCBool = 0, else UTCBool = 1. 

    @return: The adjusted end date to meet the data retrieval limit.
*/

f_FormatDates = Function( {Start, End, UTCBool},
	{Default Local}, 
	
	
	StartFormat = Char( Format( Start, "yyyy-mm-ddThh:mm:ss" ) );
	EndFormat = Char( Format( End, "yyyy-mm-ddThh:mm:ss" ) );
	
	
	
	If( ServerType == "IP21", 
	
		If( UTCBool == 0, 
		// Transform localtime in UTC 
			StartFormat = Query( Scalar, "select datetime('" || StartFormat || "', 'utc');" );
			StartFormat = Format( Informat( StartFormat, "y/m/d h:m:s" ), "yyyy-mm-ddThh:mm:ss" ) || ".000Z";
			EndFormat = Query( Scalar, "select datetime('" || EndFormat || "', 'utc');" );
			EndFormat = Format( Informat( EndFormat, "y/m/d h:m:s" ), "yyyy-mm-ddThh:mm:ss" ) || ".000Z";
		, 
		
			StartFormat = StartFormat || ".000Z";
			EndFormat = EndFormat || ".000Z";
		)
	
	);
	
	Eval List( {StartFormat, EndFormat} )
	
	;
);


/*
    f_CheckDates Function

    This function checks and adjusts date ranges to ensure that the number of data points retrieved from a server, based on the specified server type, does not exceed a defined limit. It also handles error checking and displays warnings when necessary.

    @param Start: The start date of the date range.
    @param End: The end date of the date range.
    @param PeriodValueSecond: The time interval (in seconds) between data points.
    @param Limit: Threshold for number of estimated rows by tag (numeric). If Limit = "None", no limit applied (happens with preview).
    @param ServerType: The type of server being used for data retrieval.

    @return: The adjusted end date to meet the data retrieval limit.
*/

f_CheckDates = Function( {Start, End, PeriodValueSecond, Limit, ServerType},
	{Default Local}, 
	
	If( Start >= End,
		f_DialogError( "Invalid dates" )
	);
	
	NRows_estimated = (End - Start) / PeriodValueSecond;
	
	If( Char( Limit ) != "None", 
	
		If( NRows_estimated > Limit, 
	
			End = Start + PeriodValueSecond * Limit;
		
			f_DialogWarning(
				"Number of points exceeeding the limit (" || Char( Limit ) || ") : Reducing the endDate - " || Char(
					Format( End, "yyyy-mm-ddThh:mm:ss" )
				)
			);
		
		)
	);
	
	// Local server time
	ServerDateTime_value = f_SQL_GET_LOCALTIME( ServerType );
	ServerDateTime_value = Floor( ServerDateTime_value / PeriodValueSecond ) * PeriodValueSecond; // rounding date
		
	// In case user is in a more advanced time zone
	If( End > ServerDateTime_value,
		End = ServerDateTime_value;
		f_DialogWarning(
			"The user is in a more advanced time zone than the server. Reseting end time to the current and local server time - " ||
			Char( Format( ServerDateTime_value, "yyyy-mm-ddThh:mm:ss" ) )
		);
	);
	
	Return( End );
);

/*
    f_RunExtraction Function
    
    This function automates the process of extracting data for a list of tags over a specified time range.
    
    @param lstTags: Tags to extract (list of characters, cleaned from unit and description).
    @param StartFormat: Start date (UTC format, character).
    @param EndFormat: End date(UTC format, character).
    @param ServerType: "IP21" or "PI" (character).
    @param Filters_AA: Associative array with the filters (associative array).
    @param NRow_limit_IP21: Row Limit for IP21. By default, 1,000,000 (integer), see EXPR_CONFIG.JSL to modify it.
    @param NRow_limit_PI: Row limit for PI. By default, 1,000,000 (integer), see EXPR_CONFIG.JSL to modify it.
    
    @return The post-processed tag table after extraction.
*/
f_RunExtraction = Function(
	{lstTags, StartFormat, EndFormat, ServerType, Filters_AA, NRow_limit_IP21 = NRow_limit_IP21, NRow_limit_PI = NRow_limit_PI}, 

	If( (Num( "3.14" ) == 3.14),
		is_EN_num_format = 1, //"English numeric format"
		is_EN_num_format = 0 //"Non-english");
	);
					
			
	If( is_EN_num_format == 0,
		Preferences( Use JMP Locale Settings( 0 ) )
	);
	

	/* I. CHECK INPUTS  ---------------------------------------------------------------------------------------------------------------------- */
	
	
/* 1.1. Tags */

	If( N Items( lstTags ) == 0,
		f_DialogError( "No tags selected" )
	);


	NCol_Criteria = Match( ServerType, "IP21", 8, "PI", 7 );


	/* 1.3. Extraction parameters */
	
	Try( f_SetUp4Extraction( ServerType ), f_DialogError( "Server connection failed" ) );
	
	
/* II. DATA EXTRACTION  ---------------------------------------------------------------------------------------------------------------------- */

	
/* 2.1. Filters */

	__SQL_FILTERS = f_SQL_CREATE_ALL_FILTERS( StartFormat, EndFormat, Filters_AA, Condition, ServerType );
	
	
	/* 2.2. SQL for Data Extraction */
	
	__SQL_EXTRACTION = f_SQL_EXTRACT_TAGS( StartFormat, EndFormat, __SQL_FILTERS, ServerType );
	
	If( ServerType == "IP21",
		SQL_connection_str = Substitute( __SQL_MES_CONNECTION, "VAR_MES", MES );
		Try(
			dbc = Create Database Connection( SQL_connection_str ),
			Close Database Connection( dbc );
			f_DialogError( "Server connection failed" );
		);
	,
		__SQL_EXTRACTION = f_SQL_query_to_line( __SQL_EXTRACTION )
	);
	
	
	/* 2.3. Parameters */
	
	N_NotEmpty_Tags = 0;
	n_attempts = 0;
	isExtracting = 1;
	N_Extracted_tags = 0;
	lstInitialTags = lstTags;
	NTags = N Items( lstTags );
	lst_AlreadyExtractedtags = {};
	lst_NotExtractedTags = {};
	last_status = ""; 							// Initialization of extraction statut (FAILED / SUCCESSFULL), used to reset the number of attempt
	TagExtract_AA = Associative Array();
	TagType_AA = Associative Array();
	TOTAL_TimeExtraction_START = As Date( Today() );


	/* 2.4. Data Extraction */
	
	While( isExtracting & n_attempts <= max_n_attempts, 
	
	// Removes extracted tags from querylist (in case for loop breaks due to extract errors) 
		Array_lsttags = Associative Array( lstTags, 1 :: N Items( lstTags ) );
		lstTags = (Array_lsttags << Remove( Associative Array( lst_AlreadyExtractedtags ) ) << get keys)[Rank( Array_lsttags << get values )];
		N_Remaining_tags = N Items( lstTags );
		
		If( ServerType == "IP21",
			dbc = Create Database Connection( SQL_connection_str )
		);
	
		// Initialize Loading bar
		workload = N_Remaining_tags;
		progress:init( workload, WindowSize );
		
		For( i_tag = 1, i_tag <= N_Remaining_tags, i_tag++, 
		
		
		// Reset the number of attempts if the last extraction was successfull
			If( And( last_status == "SUCCESSFULL", n_attempts > 0 ),
				n_attempts = 0
			);

	
		// Timer (per tag)
			ts_tag_extracton_Starts = As Date( Today() );
			
			
		// Get Tag name
			TagName = lstTags[i_tag];
			StrInfoButton = "Extracting : " || Char( i_tag ) || " / " || Char( N_Remaining_tags );
			strInfo = StrInfoButton || " - " || Char( TagName ) || "\!r";
			
		
		
		// Display the estimating time if not the first tag running
			If( i_tag == 1,
				strInfo || " estimating time";
				StrInfoButton = StrInfoButton || " estimating time";
			,
				Try( strInfo = strInfo || " " || Char( ::t_remaining_min ) || " MIN LEFT" );
				Try( StrInfoButton = StrInfoButton || " " || Char( ::t_remaining_min ) || " MIN LEFT" );
			);
			Print( "--------------------------------------------------------------------------------------" );
			f_Log( "INFO", strInfo );
			
			// Loading bar
			progress:set( i_tag, strInfo );
			
			Try(
				bttn_Extraction << Set Button Name( StrInfoButton );
				bttn_Extraction2 << Set Button Name( StrInfoButton );
			);
			
		// Save the initial SQL Query template in __SQL_EXTRACTION_Initial
			__SQL_EXTRACTION_Initial = __SQL_EXTRACTION;
			__SQL_EXTRACTION = Substitute( __SQL_EXTRACTION, "VAR_TAGNAME", TagName );
			
		// Send SQL Query
			If( ServerType == "IP21", 
			
				f_Log( "INFO", "<SQL Query> \!n\!n" || __SQL_EXTRACTION || "\!n\!n" );
				//IP21 SQL QUERY
				tblTag = Eval( Eval Expr( Execute SQL( dbc, __SQL_EXTRACTION, Expr( strTableVisibility ) ) ) );
				Try( tblTag << Set Name( "Tag loop extraction Results" ) );
			, 
				
				// PI SQL QUERY
				query_result = f_Convert_In_PowershellScript( ps_path, NetworkNode, __SQL_EXTRACTION );
				Try(
					tblTag = Open( query_result, "text", invisible );
					tblTag << Show Window( 0 );
					tblTag << Set Name( "Tag loop extraction Results" );
				,
					Try( Close( tblTagsProcessed, nosave ) );
					Try( Close( tblTag, NoSave ) );
					progress:term();
					f_DialogError( "No matching data" );
				);
			);
						
		
	/* 2.5. Attempt in case of disconnexion */
		
			Try(
				N Cols( tblTag ),
				progress:term();
				f_DialogError( "Server connection failed" );
			);
			// If table is changed, n_columns must assert this condition to continue:
			If( Or( N Cols( tblTag ) < NCol_Criteria, And( Is Empty( tblTag ), N Cols( tblTag ) < NCol_Criteria ) ), 
				
				// Increment the number of attempts done
				n_attempts = n_attempts + 1;
				last_status = "FAILED";
				
				f_Log(
					"WARNING", "Extraction failed - Trying to connect to the server again, JMP will wait " || Char( n_attempts ) || " seconds ",
					"DATA EXTRACTION"
				);
				

				// Reset the SQL query
				__SQL_EXTRACTION = __SQL_EXTRACTION_Initial;
				
				// Close tables
				Close( tblTag, nosave );
				Open Log( 1 );
				
				
	/* 2.6. Max number of attempts */
			
				If( n_attempts > max_n_attempts, 
					
					 
					f_Log( "WARNING", "Max number of attempts atteint.", "DATA EXTRACTION" );
					
					// Stop progress bar
					progress:term();

					Try(
					
						If( N Row( tblTagsProcessed ) > 0, 
						
							// Ifsome tags were extracted, display them
							Try(
								bttn_Extraction << Set Button Name( "Run extraction" );
								bttn_Extraction << enabled( 1 );
								bttn_Extraction2 << Set Button Name( "Run extraction" );
								bttn_Extraction2 << enabled( 1 );	
						
							);
							
							// Search which tags were not extracted
							Tags_extracted = tblTagsProcessed << Get column names( "String" );
							// Remove TS/TS_UTC 
							Remove From( Tags_extracted, As List( Loc( Tags_extracted, "TS" ) ) );
							Remove From( Tags_extracted, As List( Loc( Tags_extracted, "TS_UTC" ) ) );

							
							f_DialogWarning(
								"Server connection failed. " || Char( N Items( Tags_extracted ) ) || " / " || Char( N Items( lstInitialTags ) ) ||
								" tags extracted"
							);
							
							Break();
						)
					, 
						// If empty table, close all
						Try( Close( tblTagsProcessed, nosave ) );
						progress:term();
						f_DialogError( "Server connection failed" );
						
					);
				); // End If n_attempts > max_n_attempts
		
					
				If( ServerType == "IP21",
					Try( Close Database Connection( dbc ) )
				);
				
				f_Log( "INFO", "Number of attempts - " || Char( n_attempts ), "DATA EXTRACTION" );
				Wait( n_attempts );
				Try( tblTagsProcessed << showwindow( 0 ) );
				Try( tblSummary << showwindow( 0 ) );
				Break(); // exiting for loop
			); // End if Is Empty( tblTag ) | Not( N Cols( tblTag ) == 8
			 

/* 2.7. No tag result handling */
	
			If( N Rows( tblTag ) == 0, 
			
				f_Log( "WARNING", "No result found - probably a non-numeric data type tag.", "DATA EXTRACTION" );
				Insert Into( lst_NotExtractedTags, TagName );
			, 
				// If the tblTag is not empty preprocess the table Tag
				tblTag << SetName( "Table with TAG Results" );
				N_NotEmpty_Tags = N_NotEmpty_Tags + 1; // Increment the number of non empty tags
				
				
		
				
/* III. FORMATTING DATA OUTPUT TABLE  ---------------------------------------------------------------------------------------------------------------------- */
	
		
				tblTagsProcessed = f_PostProcess( tblTag, ServerType, strTableVisibility );
				
				last_status = "SUCCESSFULL";
			);
			
			// Close table
			Close( tblTag, nosave );
			// Add the tag to the list of extracted Tags
			Insert Into( lst_AlreadyExtractedtags, TagName );
			// Change back the SQL Query
			__SQL_EXTRACTION = __SQL_EXTRACTION_Initial;
			
	
	/* IV. EXTRACTION DETAILS  ---------------------------------------------------------------------------------------------------------------------- */

	
/* 4.1. Tag extraction time */
		
			// Timer (per tag)
			ts_tag_extracton_ends = As Date( Today() );
			ts_tag_extraction_s = Date Difference( ts_tag_extracton_Starts, ts_tag_extracton_ends, "Second", "Start" );
				
			If( i_tag == 1,
				::t_remaining_min = Ceiling( ts_tag_extraction_s * N_Remaining_tags / 60 )
			);
			
			f_Log( "INFO", "Tag extraction time : " || Char( ts_tag_extraction_s ) || " seconds", "DATA EXTRACTION" );

			
			// Increment the number of tags successfully extracted
			N_Extracted_tags = N_Extracted_tags + 1;
	
		); // End for loop tags
		
		If( N_Extracted_tags == NTags,
			isExtracting = 0;
			
		);

	); //End while loop tags
	
	
/* 4.2. Total extraction time */

	// Stop progress bar
	progress:term();
	
	TOTAL_TimeExtraction_END = As Date( Today() );
	f_Log(
		"INFO", "Total extraction time : " || Char( Date Difference( TOTAL_TimeExtraction_START, TOTAL_TimeExtraction_END, "Second" ) ) || " seconds",
		"DATA EXTRACTION"
	);

	
	// Check if at least one tag to analyze	
	If( N_NotEmpty_Tags == 0,
		Try( Close( tblTagsProcessed, nosave ) );
		Try(
			bttn_Extraction << Set Button Name( "Run extraction" );
			bttn_Extraction << enabled( 1 );
			bttn_Extraction2 << Set Button Name( "Run extraction" );
			bttn_Extraction2 << enabled( 1 );
		);
		f_DialogError( "No matching data" );
	);
	
/* 4.3. Total extraction time */
	
	If( N Items( lst_NotExtractedTags ) > 0, 

		f_DialogWarning(
			Char( N Items( lst_NotExtractedTags ) ) || " / " || Char( N Items( lstInitialTags ) ) || " tags not extracted : \!r" ||
			Concat Items( lst_NotExtractedTags, "\!r" )
		);
		
	); 

	Try(
		bttn_Extraction << Set Button Name( "Run extraction" );
		bttn_Extraction << enabled( 1 );
		bttn_Extraction2 << Set Button Name( "Run extraction" );
		bttn_Extraction2 << enabled( 1 );
	);
	
	// Disconnect from server if IP21
	If( ServerType == "IP21",
		Try( Close Database Connection( dbc ) )
	);
	
	

	If( is_EN_num_format == 0,
		Preferences( Use JMP Locale Settings( 1 ) )
	);

/* 4.4. Timestamp columns process */

	tblTagsProcessed:TS_UTC << data type( numeric ) << modeling type( continuous ) << Format( "yyyy-mm-ddThh:mm:ss" );
	Try( int.date2test = Informat( Column( tblTagsProcessed, "TS" )[1] ), int.date2test = Column( tblTagsProcessed, "TS" )[1] );
	If( !(Is Missing( Format( int.date2test, "yyyy-mm-ddThh:mm:ss" ) )),
		tblTagsProcessed:TS << data type( numeric ) << modeling type( continuous ) << Format( "yyyy-mm-ddThh:mm:ss" )
	);
	

	// Sort final table
	tblTagsProcessed << Sort( By( :TS_UTC ), Replace Table, Order( Ascending ) );
	
	Return( tblTagsProcessed );
	
);


/*
    f_SummaryTAG Function
        
    This function takes a post-processed tag table, extracts essential information, and generates a summary table
    that provides key statistics for each tag, including minimum, maximum, average, and standard deviation.
    
    @param tblAllTags: The table containing post-processed tag data.
    @param ServerType: The type of server, which can be "IP21" or "PI".
    
    @return: The summary table containing statistical information for each tag.
*/
f_SummaryTAG = Function( {tblAllTags, ServerType}, 
		
	
	/* 1. Tag table information */
	
	NRows = N Rows( tblAllTags );
	Colnames = tblAllTags << Get column names( "String" );
	Remove From( Colnames, As List( Loc( Colnames, "TS" ) ) );
	Remove From( Colnames, As List( Loc( Colnames, "TS_UTC" ) ) );
	NCol = N Items( Colnames );

	/* 2. Create summary table */
	
	tblSummary = New Table( "Summary table",
		Add Rows( 0 ),
		New Column( "NAME", Character ),
		New Column( "DESCR", Character ),
		New Column( "EU", Character ),
		New Column( "TYPE", Character ),
		New Column( "N Rows", Numeric, "Continuous", Format( "Best", 12 ), Set Values( [] ) ),
		New Column( "Mean", Numeric, "Continuous", Format( "Best", 12 ), Set Values( [] ) ),
		New Column( "Std Dev", Numeric, "Continuous", Format( "Best", 12 ), Set Values( [] ) ),
		New Column( "Max", Numeric, "Continuous", Format( "Best", 12 ), Set Values( [] ) ),
		New Column( "Min", Numeric, "Continuous", Format( "Best", 12 ), Set Values( [] ) ),
		New Column( "Range", Numeric, "Continuous", Format( "Best", 12 ), Set Values( [] ) ),
		"Invisible"
	);

	
	/* 3. Fill summary table */

	For( i_col = 1, i_col <= NCol, i_col++, 
	
		TagWithDesc = Column( tblAllTags, Colnames[i_col] ) << Get Property( "tagname_desc_unit" );
		Tag = Column( tblAllTags, Colnames[i_col] ) << Get Property( "tagname" );
		TagType_i = Column( tblAllTags, Colnames[i_col] ) << Get Property( "tagtype" );
	
		
		If( ServerType == "IP21", 
			
			If( TagType_i == "Analog" | TagType_i == "AI",
				Column( tblAllTags, Colnames[i_col] ) << data type( numeric ) << modeling type( continuous )
			);
				
			If( Or( TagType_i == "Discrete", TagType_i == "DI" ) & TableIP21 == "HISTORY(80)",
				Column( tblAllTags, Colnames[i_col] ) << Set Modeling Type( "Ordinal" )
			);
		);
		
		val = Column( tblAllTags, Colnames[i_col] ) << Get values;
		
		// Remove the tagname part in the colname to only have the remaining unit and description
		desc_unit_only = Substitute( Colnames[i_col], Tag, "" );
		desc = Munger( desc_unit_only, Contains( desc_unit_only, "(" ) + 1, (Contains( desc_unit_only, "[" ) - Contains( desc_unit_only, "(" )) - 3 );
		unit = Munger( desc_unit_only, Contains( desc_unit_only, "[" ) + 1, (Contains( desc_unit_only, "]" ) - Contains( desc_unit_only, "[" )) - 1 );
		tblSummary << AddRows(
			{:NAME = Char( Tag ), :Name( "N Rows" ) = N Rows( tblAllTags ), :DESCR = Char( desc ), :EU = Char( unit ), :TYPE = Char( TagType_i ),
			:Mean = Mean( val ), :Std Dev = Std Dev( val ), :Max = Max( val ), :Min = Min( val ), :Range = Range( val )[2] - Range( val )[1]}
		);
	
		
	); // End for loop
	
	// Add column Tag Unit description	
	tblSummary << New Column( "tag_unit_description",
		"Character",
		Formula( Char( :NAME ) || " (" || Char( :DESCR ) || ") [" || Char( :EU ) || "]" )
	);	
		// Hide column Tag Unit description
	Column( tblSummary, "tag_unit_description" ) << Hide( 1 );
	
	Return( tblSummary );
		
									
);


/*
    f_PostProcess Function
    
    
    This function is used to post-process a JMP Table containing the tags that have been extracted.
    It arranges the tags into columns based on the server type, and allows specifying the visibility of the table.
    
    @param tblTag: JMP Table with the extracted tags.
    @param ServerType: The type of server, either "IP21" or "PI".
    @param strTableVisibility: Visibility of the table ("invisible", "private", "visible").
    
    @return: The post-processed tag table.
*/
f_PostProcess = Function( {tblTag, ServerType, strTableVisibility}, 

		
	/* 1. Create column "tag_unit_description" */
	
	tblTag << New Column( "tag_unit_description", "Character", Formula( Char( :NAME ) || " (" || Char( :DESCR ) || ") [" || Char( :EU ) || "]" ) );	
	
	TagDescUnit = Column( tblTag, "tag_unit_description" )[1];
	strTagType = Column( tblTag, "TAGTYPE" )[1]; 
	
	TagExtract_AA[TagDescUnit] = TagName;
	TagType_AA[TagDescUnit] = strTagType;

	/* 2. Concatenate tag tables */
	
	Try(
		Data Table( tblAllTags );
		TransposedtableExist = 1;
	,
		TransposedtableExist = 0
	);
			
	If( TransposedtableExist == 0, 
	
		// If the tblAllTags do no exist yet, we create it
		
		Eval(
			Eval Expr(
				tblAllTags = tblTag << Split(
					Split By( :tag_unit_description ),
					Split( Column( tblTag, "VALUE" ) ),
					Group( :TS, :TS_UTC ),
					Remaining Columns( Drop All ),
					Sort by Column Property,
					Expr( strTableVisibility )
				)
			)
		)
	, 
	
		// IF TranspoedtableExist already, we update it
		
		Eval(
			Eval Expr(
				tblTag_Transposed_NEW = tblTag << Split(
					Split By( :tag_unit_description ),
					Split( Column( tblTag, "VALUE" ) ),
					Group( :TS, :TS_UTC ),
					Remaining Columns( Drop All ),
					Sort by Column Property,
					Expr( strTableVisibility )
				)
			)
		);
		
		
		// Outer join	
		Eval(
			Eval Expr(
				tblTag_Merged = tblAllTags << Join(
					With( tblTag_Transposed_NEW ),
					By Matching Columns( :TS = :TS, :TS_UTC = :TS_UTC ),
					Drop multiples( 0, 0 ),
					Include Nonmatches( 1, 1 ),
					Preserve main table order( 1 ),
					Expr( strTableVisibility )
				)
			)
		);
		
		// The join obliged us to create a new table, so we will close tblAllTags and re-create it
		Close( tblAllTags, nosave ); // comment this line to leave table open	
		Close( tblTag_Transposed_NEW, nosave ); // comment this line to leave table open
		
		// Re-create tblAllTags
		tblAllTags = Eval( Eval Expr( tblTag_Merged << Subset( All rows, Selected columns only( 0 ), Expr( strTableVisibility ) ) ) );
		Close( tblTag_Merged, nosave ); 

		/* 3. Check for nonmatches in the join (First column missing) */
		
		lst_colnames = tblAllTags << Get column names( "String" );
		first_col = lst_colnames[1]; // TS  column
		n_col = N Items( lst_colnames );
		row_missing = Eval( Eval Expr( tblAllTags << Get rows where( Is Missing( Expr( Parse( ":Name(\!"" || Char( first_col ) || "\!")" ) ) ) ) ) );
		
		
		If( N Items( row_missing ) > 0, 

			// IF NOMATCHES
			
			// Get TS/UTC values columns there are nomatches and replace them in the 2 first columns
			
			TS_nomatches = (Column( tblAllTags, n_col - 2 ) << Get values())[row_missing];
			TS_UTC_nomatches = (Column( tblAllTags, n_col - 1 ) << Get values())[row_missing];
			
			For( i = 1, i <= N Items( row_missing ), i++,
				Column( tblAllTags, 1 )[row_missing[i]] = TS_nomatches[i]; // TS
				Column( tblAllTags, 2 )[row_missing[i]] = TS_UTC_nomatches[i]; //TS_UTC
			);

		); // End If  N Items( row_missing ) > 0

		// remove the additional columns TS/TS_UTC created during the outer join 
		tblAllTags << delete column( n_col - 1 );
		tblAllTags << delete column( n_col - 2 );
			
		// Rename correctly fist columns TS/TS_UTC
		Column( tblAllTags, 1 ) << Set Name( "TS" );
		Column( tblAllTags, 2 ) << Set Name( "TS_UTC" );

				
	);
	
	Return( tblAllTags );
			
);

/****************************************************
*  IV. UTILITIES FOR GUARDBAND CHART
******************************************************/


/*
    f_GetGuardbandPath Function
    
    
    This function calculates the expected path where will be stored the guardband table for a given analysis.
    
    @param dt: Table with batches (table).
    
    @param MES: MES name (str).
    
    @param TagSelect_AA: Associative array which make the link between tagnames without unit/desc AND  tagnames with desc/unit.
    
    @param ignore_options: Boolean (1 or 0), 0 by default. Special case if we want to ignore the options in guardband UI.
    
    @return: The expected path for the results.
*/
f_GetGuardbandPath = Function( {dt, MES, TagSelect_AA, ignore_options = 0}, 
	
	
	// Settings
	
	lst.lot = (collistbox.lot << GetItems);
	lst.step = (collistbox.step << GetItems);
	lst.param = (collistbox.parameter << GetItems);
	lst.id = (collistbox.id << GetItems);
	str.guardband_name = txteditbx.guardband_table_name << Get text;
	Try( int.Opt_use_existing_guardbands = chkbox.use_existing_guardbands << Get(), int.Opt_use_existing_guardbands = 0 );
	
	int.nb_param = N Items( lst.param );
	int.nb_lot = N Items( lst.lot );
	int.nb_step = N Items( lst.step );
	int.nb_id = N Items( lst.id );
	
	// Path
	
	If( And( int.Opt_use_existing_guardbands == 1, ignore_options == 0 ),
		Try( Return( str.path4guardband_selected ), Return( "" ) )
	);
	
	If( int.nb_lot + int.nb_param <= 1,
		Return( "" )
	);
	
	str.parameter = lst.param[1];
	
	
	str.path_guardband4analysis = Convert File Path( strPathGuardband ) || Char( MES ) || "/";
	
	// Add ID in the path
	If( int.nb_id > 0,
		str.id = lst.id[1];
		str.id_cleaned = f_Remove_UnitDescription( Char( Column( dt, str.id )[1] ), TagSelect_AA );
		str.id_cleaned = f_Remove_SpecialCharacters( str.id_cleaned );
		str.path_guardband4analysis = str.path_guardband4analysis || "ID_" || Char( str.id_cleaned );
	,
		str.path_guardband4analysis = str.path_guardband4analysis || "ID_Unknown"
	);

	// Add parameter
	str.parameter_clean = f_Remove_UnitDescription( str.parameter, TagSelect_AA );
	str.parameter_clean = f_Remove_SpecialCharacters( str.parameter_clean ); // To not have issue in Windows/Linux directory
	str.path_guardband4analysis = str.path_guardband4analysis || "/" || Char( str.parameter_clean );
	
	Return( str.path_guardband4analysis || "/" || f_Remove_SpecialCharacters( str.guardband_name ) || ".jmp" );
);
	
/*
    f_AlignBatch Function
    
    
    This function takes a table with batches, aligns their length to the shortest batch, and returns a modified table suitable for creating a Guardband chart. You can specify the column names for batches and the parameter to plot. Optionally, you can use backup bandguards from another table.
    
    @param tblMain: Table with batches (table).
    
    @param strColBatch: Column name corresponding to the batches in the table (character).
    
    @param strParam: Column name corresponding to the parameter to plot in the guardband chart (character).
    
    @param UseBackup: Indicates whether to use backup bandguards (0 or 1).
    
    @param TableBackup: JMP table with backup bandguards (table, used only if UseBackup = 1).
    
    @param strTableVisibility: Visibility of the temporary tables (character).
    
    @return: JMP table with batches aligned.
*/
f_AlignBatch = Function( {tblMain, strColBatch, strParam, UseBackup, TableBackup, strTableVisibility},
	{Default Local}, 
	
// Check which of the batches got the shortest 
	If( N Rows( tblMain ) == 0,
		f_DialogError( "Table empty" )
	);
	
	Eval(
		Eval Expr(
			tblBatches = tblMain << Summary(
				Group( Parse( ":Name(\!"" || Char( strColBatch ) || "\!")" ) ),
				Freq( "None" ),
				Weight( "None" ),
				Expr( strTableVisibility )
			)
		)
	);
	lstBatch = Column( tblBatches, 1 ) << Get values;
	lstBatchRows = Column( tblBatches, 2 ) << Get values;
	Close( tblBatches, nosave );
	
	f_Log( "INFO", "The smallest batch has " || Char( Min( lstBatchRows ) ) || " row(s)." );
	
	If( UseBackup == 1,
		Min_Row = N Rows( TableBackup );
		f_Log( "INFO", "The smallest batch on the backup guardbands used has " || Char( N Rows( TableBackup ) ) || " rows." );
	,
		Min_Row = Min( lstBatchRows )
	);

	
	// Got the shortest step and deleted all the rest from the other batches
	lstSelectedRows = {};
			// Loop on batches
	For( i_batch = 1, i_batch <= N Items( lstBatch ), i_batch++, 
			
		strBatch = lstBatch[i_batch];
		Eval( Eval Expr( lstRows = tblMain << Get Rows Where( Expr( Parse( ":Name(\!"" || Char( strColBatch ) || "\!")" ) ) == strBatch ) ) );
		For( j = 1, j <= Min_Row, j++,
			Try( Insert Into( lstSelectedRows, lstRows[j] ) )
		);
	); // END LOOP BATCH
			
	Eval( Eval Expr( tblMain_Aligned = tblMain << Subset( Rows( lstSelectedRows ), Selected Columns( 0 ), Expr( strTableVisibility ) ) ) );
	tblMain_Aligned << Set Name( "Guardband table aligned" );
			
	// Create batch column
	Eval(
		Eval Expr(
			tblMain_Output = tblMain_Aligned << Split(
				Split By( Expr( Parse( ":Name(\!"" || Char( strColBatch ) || "\!")" ) ) ),
				Split( Expr( Parse( ":Name(\!"" || Char( strParam ) || "\!")" ) ) ),
				Sort by Column Property,
				Expr( strTableVisibility )
			)
		)
	);
	Close( tblMain_Aligned, nosave );
	
	Return( tblMain_Output );
);

/*
    f_Create_OOC_Column Function
    
    
    This function generates OOC columns used to highlight OOC in red.
    
    @param tbl.guardband: Table for Guardband (table).
    
    @param str.batch: Name of the batch (str)

    
    @return: A string containing the Guardband plot script.
*/
f_Create_OOC_Column = Function( {tbl.guardband, str.batch, lst.LCL_values, lst.UCL_values}, 

	str.new_colname = "OOC - " || Char( str.batch );
	int.nb_rows = N Rows( tbl.guardband );
	lst.batch_col_values = As List( Column( tbl.guardband, Char( str.batch ) ) << Get values() );
	Try( Eval( Eval Expr( tbl.guardband << Delete Columns( Expr( str.new_colname ) ) ) ) );
	tbl.guardband << New Column( str.new_colname, Numeric, "Continuous", Format( "Best", 12 ) );
	Column( tbl.guardband, str.new_colname ) << Hide( 1 );

	For( i = 1, i <= int.nb_rows, i++, 
		
		LCL_i = lst.LCL_values[i];
		UCL_i = lst.UCL_values[i];
		colvalue_i = lst.batch_col_values[i];
		
		// Check if > UCL
		If( colvalue_i > UCL_i, 
		
			Column( tbl.guardband, str.new_colname )[i] = colvalue_i;
			
		
		);
		
		
		// Check if < LCL
		If( colvalue_i < LCL_i, 
		
			Column( tbl.guardband, str.new_colname )[i] = colvalue_i;
		
		);
		
	);
	

);


/*
    f_GuardbandChart Function
    
    
    This function generates a script for creating a Guardband plot using the provided table, lists of batches, steps, IDs, and products. The script can be executed in JMP to visualize Guardband charts.
    
    @param tbl.guardband : Table for Guardband (table).
    
    @param strParam: Name of the parameter to be plotted (str)
    
    @param lstBatch: List of batches (list).
    
    @param lstStep: List of steps (list).
    
    @param lstID: List of IDs (list).
    
    @param lstProduct: List of products (list).
    
    @param int.Opt_clean_data: Boolean, indicates if data cleaning was enabled or not (int).

    @param str.log_contents: Guardband log (str).

    @param WindowSize: Window size (list).

    
    @return: A string containing the Guardband plot script.
*/
f_GuardbandChart = Function( {tbl.guardband, strParam, lstBatch, lstStep, lstID, lstProduct, int.Opt_clean_data, str.log_contents, WindowSize},
	{Default Local}, 
	

	intNBatches = N Items( lstBatch );
	intNStep = N Items( lstStep );
	intNID = N Items( lstID );
	intNProduct = N Items( lstProduct );
	
	// Y Variables
	strAddY = "";
	For( i = 1, i <= intNBatches, i++,
		strAddY = strAddY || ", Y( " || Char( ":Name(\!"" || Char( lstBatch[i] ) || "\!")" ) || ", Position( 1 ) ), Y( " ||
		Char( ":Name(\!"OOC - " || Char( lstBatch[i] ) || "\!")" ) || ", Position( 1 ) )"
	);
	
	// Elements
	strAddElements = "";
	For( i = 1, i <= intNBatches, i++,
		strAddElements = strAddElements || ", Y(" || Char( intNStep + i ) || ")"
	);
	For( i = 1, i <= intNBatches, i++,
		strAddElements = strAddElements || ", Y(" || Char( intNStep + intNBatches + i ) || ")"
	);
	
	// Properties
	strAddProperties = "";
	For( i = 1, i <= intNBatches, i++,
		strAddProperties = strAddProperties || ", Properties( " || Char( i ) || "\[, {Line Width( 1 )} , Item ID("]\" || Char( lstBatch[i] ) ||
		"\[", 1 ) )]\"
	);
	For( i = 1, i <= intNBatches, i++,
		strAddProperties = strAddProperties || ", Properties( " || Char( intNBatches + i ) ||
		"\[, {Line Width( 1 ), Line Color( 3 )} , Item ID("OOC - ]\" || Char( lstBatch[i] ) || "\[", 1 ) )]\"
	);
	
	// Remove OOC legend
	lst.legend = List();
	For( i = 1, i <= intNBatches, i++,
		Insert Into( lst.legend, i );
		Insert Into( lst.legend, -1 );
	);
	
	strRemoveOOClegend = "Dispatch(
			{},
			\!"400\!",
			LegendBox,
			{Legend Position( {16, [" ||
	Char( Matrix( lst.legend ) ) || "], 17} )}
		)";
	
	
	// Add Step if any
	If( intNStep > 0, 
	
		strStep = lstStep[1];
	
		strAddY = ", Y( " || Char( ":Name(\!"" || Char( strStep ) || "\!")" ) || "\[ , Side( "Right" ) ) ]\" || Char( strAddY );
		strAddProperties = Char( strAddProperties ) || "\[, Properties( -1 , {Line Color( 0 ),Line Width( 1 )},Item ID( "]\" || Char( strStep ) ||
		"\[", 1 ))), Legend Model(
				17,
				Properties(
					0,
					{Line Color( 0 ),Line Width( 1 )},
					Item ID( "]\"
		 || Char( strStep ) || "\[", 1 )
				)
			 ]\";
		
		
		strAddYStep =
		"\[,
						Line(
							X,
							Y( 1 ),
							Legend( 17 ),
							Error Interval( "None" ),
							Jitter( "None" ),
							Missing Values( "No Connection" ),
						)]\"
						
		;
	, 
						
		strAddYStep = ""
						
	);		
		
	// Set title for the guardband
	If( intNID + intNProduct > 1, 
		
		strID = Column( tbl.guardband, lstID[1] )[1];
		strProduct = Column( tbl.guardband, lstProduct[1] )[1];
		strTitle = "Guardband Chart_" || Char( strID ) || "_" || Char( strProduct );
		
	,
		strTitle = "Guardband Chart"
	);
	
	// Adjust size
	DevX = 1536;
	DevY = 874;
	ScreenX = WindowSize[1];
	ScreenY = WindowSize[2];
	RatioX = ScreenX / DevX;
	RatioY = ScreenY / DevY;
	
	//Make sure it is a character list
	lstBatch = As List( lstBatch );
	For Each( {value, index}, lstBatch,  lstBatch[index] = Char( value ) );
	
	charGUARDBAND_PLOT =
	"\[ window.guardband_chart = New Window("Guardband",
	
	Outline Box("Guardband Chart",
	H List Box( Lineup Box( N Col( 1 ), spacing( 10 ),
	Text Box("Batches selection: "),
	 listy = ListBox(
			]\"
	 || Char(  lstBatch) ||
	"\[,
			listitemy = listy << GetSelected();
			lgnd = gb_guardband << Get Legend Server;
			item = (lgnd << Get Legend Items)[ 1 ];
			For( i =1, i<=Nitems(item), i = i + 2,
				strlabel = item[i] << GetLabel();
				If( contains( listitemy, strlabel),
					item[i] << Set Properties( {Transparency( 1 )} );
					item[i+1] << Set Properties( {Transparency( 1 )} );
				,
					item[i] << Set Properties( {Transparency( 0 )} );
					item[i+1] << Set Properties( {Transparency( 0 )} );
				);
			)
			)
		),
	gb_guardband = Graph Builder(
					Size( ]\"
	 || Char( 1149 * RatioX ) || "\[ , ]\" || Char( 596 * RatioY ) ||
	"\[  ),
					Show Control Panel( 0 ),
					Legend Position( "Right" ),
					Variables(
						X( Transform Column( "Row", Formula( Row() ) ) ) ]\"
	 || Char( strAddY ) || "\[
					),
					Elements(
						Line(
							X
							]\"
	 || Char( strAddElements ) ||
	"\[,
							Legend( 16 ),
							Error Interval( "None" ),
							Missing Values( "No Connection" ),
							Jitter( "None" )
						)]\"
	 || Char( strAddYStep ) ||
	"\[
						
					),
					SendToReport(
						Dispatch(
							{},
							"Row",
							ScaleBox,
							{Min( 0 ), Max(]\"
	 || Char( N Rows( tbl.guardband ) ) ||
	"\[), Inc( 10 ), Minor Ticks( 4 ),
							Label Row( Label Orientation( "Angled" ) )}
						),
						Dispatch(
							{},
							"400",
							ScaleBox,
							{Legend Model(
								16
								]\"
	 || Char( strAddProperties ) ||
	"\[
							)}
						),
						Dispatch(
						{},
						"Graph Builder",
						FrameBox,
						{Background Color( -14605016 ), Marker Size( 0 ),
						Marker Drawing Mode( "Normal" )}
						),
						Dispatch(
						{},
						"Graph Builder",
						FrameBox,
						{Add Graphics Script(
							2,
							Description( "Script" ),
							yMatrix = tbl.guardband:UCL << get values |/
							Matrix( Reverse( As List( tbl.guardband:LCL << get values ) ) );
							xMatrix =  AsList(1::]\"
	 || Char( N Row( tbl.guardband ) ) || "\[ )[1]|/
							Matrix( Reverse( As List(  AsList(1::]\" ||
	Char( N Row( tbl.guardband ) ) ||
	"\[ )[1] ) ) );
							Transparency(0.1);
							Fill Color( "blue" );
							Polygon( xMatrix, yMatrix );
							), Grid Line Order( 1 ), Reference Line Order( 3 )}
						),
						Dispatch( {}, "graph title", TextEditBox, {Set Text( "]\"
	 || Char( strTitle ) ||
	"\[" )} ),
						Dispatch( {}, "X title", TextEditBox, {Set Text( "Time [min]" )} ),
						Dispatch( {}, "Y title", TextEditBox, {Set Text(  "]\"
	 || Char( strParam ) || "\[" )} ),
	 ]\" || Char( strRemoveOOClegend ) ||
	"\[
					)
				)
				)	
				),
				Outline Box("Information",
		Lineup Box( N Col( 1 ), spacing( 10 ),
			Text Box("This guardband chart was generated on ]\"
	 || Format( Today(), "yyyy-mm-ddThh:mm:ss" ) || "\[" ),
			Text Box("Number of batches:  ]\" || Char( intNBatches ) ||
	"\[" ),
			Text Box("Option for data cleaning ]\" || If( int.Opt_clean_data == 1,
		"enabled",
		"deactivated"
	) ||
	"\[ ")),
	
	H Center Box(
	Lineup Box( N Col( 1 ), spacing( 10 ),
			Button Box("Open table used for guardband chart", 
				tbl.guardband_copy = tbl.guardband  << Subset( All rows, Selected columns only( 0 ), "invisible" );
				tbl.guardband_copy  << New data View();
			),
			Button Box("Open log", 
				window.guardband_log = New Window( "Guardband log",
				Show Menu( 0 ),
		show toolbars( 0 ), 
							Border Box( Left( 10 ), Right( 10 ), Top( 10 ), Bottom( 5 ),
								V List Box(
									Border Box( Sides( 4 ),
										th = Text Box(
											"Guardband log",
											<<SetFontSize( 15 ),
											<<Set Font( "Century Gothic" ),
											<<Set Font Style( "Bold" ),
											<<set auto centering( 1, 0 ),
											<<set auto stretching( 1, 0 ),
											<<Set width( 150 )
										
										)
									),
									Border Box( Top( 20 ),
										logging_capture = Text Box(str.log_contents);
									)
								)
								
							)
						);
						logging_capture << Set Width( 800 );
						

			),
			Button Box("Close all",
				 Try(window.guardband_log << Close Window());
				  Try(Close(tbl.guardband_copy,NoSave));
				 Close(tbl.guardband , NoSave);
				 window.guardband_chart << Close Window();
			)
			)
		)
	)
				)	
			;]\";
			
	Return( Eval List( {charGUARDBAND_PLOT, strTitle} ) );
);

/****************************************************
*  V. OTHER UTILITIES
******************************************************/

/*
    f_UpdateMESInfo Function
        
    This function is used to update MES information with user-selected values, such as the index of the selected MES
    in a listbox. If there were some filters registered, they will be removed (Warning Window).
    
    @param selected_MES_index: Index of the selected MES in the lst_MES_servers listbox (integer, unique).
*/
f_UpdateMESInfo = Function( {selected_MES_index}, 

	MES = Arg( ServerURLs, selected_MES_index );
	ServerType = Arg( ServerTypeList, selected_MES_index );
	SiteName = Arg( SiteNames, selected_MES_index );
	ShortName = Arg( ShortNames, selected_MES_index );
	NetworkNode = Arg( NetworkNodes, selected_MES_index );
	ServerExtension = Arg( Extensions, selected_MES_index ); 
	
	// Update textbox with Server Address / Extension / Shortname
	txtbox_ServerAddress << Set Text( MES );
	txtbox_ServerExtension << Set Text( ServerExtension );
	txtbox_Shortname << Set Text( ShortName );
	
	// UPdate radio box IP21 /PI
	If( ServerType == "IP21",
		rdbox_ServerType << set( 1 ),
		rdbox_ServerType << set( 2 )
	);
	lstFiltersReg = lstFiltersRegistered << Get Items();
	Try(
		If( N Items( lstFiltersReg ) > 0,
			f_DialogWarning( "All filters removed" );
			lstFiltersRegistered << Remove All;
			Filters_AA = Associative Array();
			NextID = 1;
		)
	);
	
);

/*
    f_CheckMESInfo Function
        
    This function is used to verify and check the MES information provided or selected by the user. It checks
    parameters such as MES, ServerExtension, ServerType, ShortName, and whether the user has edited the MES.
    
    @param MES: The server selected.
    @param ServerExtension: The server extension.
    @param ServerType: The type of server.
    @param ShortName: The short name.
    @param is_checked: Whether the user has edited the MES or not.
*/
f_CheckMESInfo = Function( {MES, ServerExtension, ServerType, ShortName, is_checked},
	{Default Local}, 
	


	// Display MES informations in log
	f_Log(
		"INFO", "Server information - Server MES " || Char( MES ) || " / Extension " || Char( ServerExtension ) || " / Type " || Char( ServerType )
	);

	// If MES edited by the user and the extension is empty
	If( is_checked == 1,
		If( ServerExtension == "",
			NetworkNode = MES,
			NetworkNode = MES || "." || ServerExtension
		)
	);
	// If MES edited by the user and the shortname is empty
	If( And( is_checked == 1, ShortName == "" ),
		ShortName = "custom server shortname"
	);
	
	f_Log( "INFO", "Server Shortname : " || Char( ShortName ) );

	
	// If no MES filled, error message
	If( MES == "",
		f_DialogError( "Server details missing" )
	);
	
);

/*
    f_UpdateDate Function
    
    
    This function is used to convert a date, either the starting date or the end date, into the correct format
    based on the provided period value and units.
    
    @param Date: The date to be converted (integer).
    @param PeriodNumVal: The period value (integer).
    @param PeriodUnits: The period units (character).
*/
f_UpdateDate = Function( {Date, PeriodNumVal, PeriodUnits},
	{default local}, 

	
	If( PeriodUnits == "Second",
		Multi_factor = 1,
		If( PeriodUnits == "Minute",
			Multi_factor = 60,
			If( PeriodUnits == "Hour",
				Multi_factor = 60 * 60, 
			//days
				Multi_factor = 24 * 60 * 60
			)
		)
	);
	
	Offset = Num( PeriodNumVal ) * Multi_factor; // In seconds
	NewDate = Floor( Date / Offset ) * Offset;
	
	Return( NewDate );
	
);


/*
    f_SetPeriodFormat Function
    
        
    This function is used to adjust the format of the period value based on the provided period units.
    
    @param PeriodNumValue: The period value (numeric).
    @param PeriodUnits: The period unit (character).
    
    @return: The new period value (numeric).
*/
f_SetPeriodFormat = Function( {PeriodNumValue, PeriodUnits},
	{Default Local}, 
	
	If( PeriodUnits == "Second",
		Multifactor = 10,
		If( PeriodUnits == "Minute",
			Multifactor = 60 * 10,
			If( PeriodUnits == "Hour",
				Multifactor = 60 * 60 * 10, 
			//Days
				Multifactor = 24 * 60 * 60 * 10
			)
		)
	);
	NewPeriodNumValue = PeriodNumValue * Multifactor;
	
	Return( NewPeriodNumValue );
);

/*
    f_MoveUp Function
    
    
    This function allows you to reorder tags within a list by moving specific tags up.
    
    @param lstTags: List of tags to reorder (list).
    @param Tag: Tag names to move up (list).
    
    @return: The list of tag names reordered.
*/
f_MoveUp = Function( {lstTags, Tag},
	{Default Local}, 
	
	
	For( i_tag = 1, i_tag <= N Items( Tag ), i_tag++, 
	
		i = Loc( lstTags, Char( Tag[i_tag] ) );
	
		If( i != 1, 

	// Store Values
			tmp = lstTags[i - 1];
			tmp2 = lstTags[i];
	// Change order
			lstTags[i] = tmp;
			lstTags[i - 1] = tmp2;
		
		);
	);
	
	Return( lstTags );
			
);

/*
    f_MoveDown Function
    
    
    This function allows you to reorder tags within a list by moving specific tags down.
    
    @param lstTags: List of tags to reorder (list).
    @param Tag: Tag names to move down (list).
    
    @return: The list of tag names reordered.
*/
f_MoveDown = Function( {lstTags, Tag},
	{Default Local}, 
	
	
	For( i_tag = N Items( Tag ), i_tag >= 1, i_tag--, 
	
		i = Loc( lstTags, Char( Tag[i_tag] ) );
	
		If( i != N Items( lstTags ), 
	
	// Store Values
			tmp = lstTags[i + 1];
			tmp2 = lstTags[i];
	// Change order
			lstTags[i] = tmp;
			lstTags[i + 1] = tmp2;
		
		);
	);
	
	Return( lstTags );
			
);


/*
    f_SearchBarTag Function
    
    
    This function is used to filter and display the columns in the TAB Data Extraction based on user-entered search text.
    
    @param this: The reference to the TAB Data Extraction.
    @param searchText: The text entered by the user in the search bar.
    
    @return: The filtered list of columns.
*/
f_SearchBarTag = Function( {this, searchText}, 

	Try(
		item_list = TagList_DescUnit;  // Only possible if the button "Find Tag" was pressed
		// only attempt to filter if there is any text
		If( searchText != "", 
		// new list for groups that match searchText
			filtered_items = {};
		// Check if each group matches the given text
			For( i = 1, i <= N Items( item_list ), i++, 
			// Insert to our list if it contains our search text (case insensitive)
				If( Contains( Lowercase( item_list[i] ), Lowercase( searchText ) ),
					Insert Into( filtered_items, item_list[i] )
				)
			);
		, 
	// else show all groups
			filtered_items = item_list
		);
		lstAvailableTags << Set Items( filtered_items );
		txtbox_nbTags << Set text( " [ " || Char( N Items( filtered_items ) ) || " ]" );
		
		
	)
);		// end filter_items function


/*
    f_SearchBarFilter Function
    
    
    This function is used to filter and display the columns in the TAB Filters based on user-entered search text.
    
    @param this: The reference to the TAB Filters.
    @param searchText: The text entered by the user in the search bar.
    
    @return: The filtered list of columns.
*/
f_SearchBarFilter = Function( {this, searchText}, 

	Try(
		item_list = lstbox_SelectedTags << Get Items();
	// only attempt to filter if there is any text
		If( searchText != "", 
		// new list for groups that match searchText
			filtered_items = {};
		// Check if each group matches the given text
			For( i = 1, i <= N Items( item_list ), i++, 
			// Insert to our list if it contains our search text (case insensitive)
				If( Contains( Lowercase( item_list[i] ), Lowercase( searchText ) ),
					Insert Into( filtered_items, item_list[i] )
				)
			);
		, 
	// else show all groups
			filtered_items = item_list
		);
		lstbox_SelectedTags2 << Set Items( filtered_items );
	)

);		// end filter_items function

/*
    f_SearchBarServer Function
    
    
    This function is used to filter and display the servers in the TAB Data Extraction based on user-entered search text.
    
    @param this: The reference to the TAB Data Extraction.
    @param searchText: The text entered by the user in the search bar.
    
    @return: The filtered list of columns.
*/
f_SearchBarServer = Function( {this, searchText}, 

	Try(
		item_list = MES_list;
	// only attempt to filter if there is any text
		If( searchText != "", 
		// new list for groups that match searchText
			filtered_items = {};
		// Check if each group matches the given text
			For( i = 1, i <= N Items( item_list ), i++, 
			// Insert to our list if it contains our search text (case insensitive)
				If( Contains( Lowercase( item_list[i] ), Lowercase( searchText ) ),
					Insert Into( filtered_items, item_list[i] )
				)
			);
		, 
	// else show all groups
			filtered_items = item_list
		);
		lst_MES_servers << Set Items( filtered_items );
	)

);		


/*
    f_SearchBarValue Function
    
    
    This function is used to filter and display the values in the script for data manipulattion (Annotate) based on user-entered search text.
    
    @param this: The reference to the TAB Data Extraction.
    @param searchText: The text entered by the user in the search bar.
    
    @return: The filtered list of columns.
*/
f_SearchBarValue = Function( {this, searchText}, 

	Try(
		item_list = lstValue_ColAnnotate; 
		
		If( searchText != "",
			filtered_items = {};
			
			For( i = 1, i <= N Items( item_list ), i++, 
			// Insert to our list if it contains our search text (case insensitive)
				If( Contains( Lowercase( item_list[i] ), Lowercase( searchText ) ),
					Insert Into( filtered_items, item_list[i] )
				)
			);
		, 
	// else show all groups
			filtered_items = item_list
		);
		ColBx_ValAnnotate << Set Items( filtered_items );
		
	)
);		


/*
    f_Get_ControLimits

    This function get the LCL and UCL from the column property "Control Limits".
    
    Parameters: 
    - dt : Data table
    - ColName : Name of the column

*/

f_Get_ControLimits = Function( {dt, ColName},
	{Default Local}, 
	
	LstControlLimits = Column( dt, ColName ) << get property( "Control Limits" );
	LCL = "";
	UCL = "";
	
	If( !(Is Empty( LstControlLimits )), 
	
		If( N Items( LstControlLimits ) > 1,
			f_DialogWarning( "Several control limits detected for " || Char( ColName ) || ", only the first one will be considered" );
			LstControlLimits = LstControlLimits[1];
		);

		LstCleanCL = Words( Char( LstControlLimits[1] ), "(), " );
		For Each( {value, index}, LstCleanCL, Match( value, "LCL", LCL = LstCleanCL[index + 1], "UCL", UCL = LstCleanCL[index + 1] ) );
	);
	
	Eval List( {Num( LCL ), Num( UCL )} );
);




/*
    f_Get_SpecLimits

    This function get the LSL and USL from the column property "Spec Limits".
    
    Parameters: 
    - dt : Data table
    - ColName : Name of the column

*/

f_Get_SpecLimits = Function( {dt, ColName},
	{Default Local}, 
	
	LstSpecLimits = Column( dt, ColName ) << get property( "Spec Limits" );
	LSL = "";
	USL = "";
	
	If( !(Is Empty( LstSpecLimits )), 
	
		For( i = 1, i <= N Items( LstSpecLimits ), i++, 
		
			LstCleanSL = Words( Char( LstSpecLimits[i] ), "(), " );
			For Each( {value, index2}, LstCleanSL, Match( value, "LSL", LSL = LstCleanSL[index2 + 1], "USL", USL = LstCleanSL[index2 + 1] ) );

		
		)
	);
	
	Eval List( {Num( LSL ), Num( USL )} );
);


/*
    f_Get_LeveyJennings

    This function get the LSL and USL with Levey-Jennings.
    
    Parameters: 
    - dt : Data table
    - ColName : Name of the column

*/

f_Get_LeveyJennings = Function( {dt, ColName},
	{Default Local}, 


	lst.rows2exclude = dt << get excluded rows();
	lst.col_values = As List( Column( dt, Colname ) << get values );
	
	For( i = N Items( lst.rows2exclude ) + 1, i = i - 1, i >= 1,
		Remove From( lst.col_values, lst.rows2exclude[i] )
	);
	
	y_bar = Mean( lst.col_values );
	sigma = Std Dev( lst.col_values );
	
	UCL = y_bar + 3 * sigma;
	LCL = y_bar - 3 * sigma;
	
	Eval List( {Num( LCL ), Num( UCL )} );
);

/*
    f_CenterWindow

    This function center the window w.r.t the user's screen.
    
    Parameters: 
    - Window : JMP Window
    - ScreenSize : Size {x,y} of the user's screen

*/
f_CenterWindow = Function( {Window, ScreenSize},
	{Default local}, 
	
	WindowSize = Window << Get Window Size();
	
	XPos = (ScreenSize[1] - WindowSize[1]) / 2;
	YPos = (ScreenSize[2] - WindowSize[2]) / 2;
	Window << move window( XPos, YPos );
);

/* 	f_openFileInOSDefault
	
	This function open file in the operating system default program
	
	Parameters: 
		filepath - local path file
*/
f_openFileInOSDefault = Function( {filepath},
	If( Host is( "Windows" ),
		Run Program(
			Executable( "PowerShell.exe" ),
			Options( Eval Insert( "\[-Command "& {Start-Process '^filepath^'}"]\" ) ),
			Read function( "text" )
		),
		Run Program( Executable( "/usr/bin/open" ), Options( filepath ), ReadFunction( "text" ) )
	)
);



/****************************************************
*  VI. COMMUN BUTTONS FOR ATTACHED SCRIPTS
******************************************************/


/*
    f_button.update_filter Function
    
    This function is associated with the "Update Filter" button and is utilized across multiple scripts ("Update/Refresh", "Add tags") to facilitate the refinement and preview of data filtration.
    
    @param this: The reference to the associated script or user interface.
    
*/

f_button.update_filter = Function( {}, 
	
	/* 3.1 Filter */
	
	section = "UPDATE FILTER";
	
	Try( FilterSelected = (lstFiltersRegistered << GetSelected())[1], f_DialogError( "No filter selected" ) );
	
	If( N Items( lstFiltersRegistered << GetSelected() ) > 1,
		f_DialogError( "Select one filter" )
	);
	
	IDFilterSelected = (lstFiltersRegistered << Get Selected Indices())[1];
	// IDFilterSelected = 1
	lstFilterSelected = Filters_AA[IDFilterSelected];
	
	
	
	If( Is List( lstFilterSelected[1] ),
		f_DialogError( "Can't update a nested filter" )
	);
	f_Log( "INFO", "User wants to update the following filter -  " || Char( FilterSelected ) );
	
	TagName_DescUnit = lstFilterSelected[1];
	TagName = f_Remove_UnitDescription( TagName_DescUnit, TagSelect_AA );
	strTagType = TagType_AA[TagName_DescUnit];
	
		
	f_Log( "INFO", "The tag to update is of the type " || Char( strTagType ), section );
	
	
	/* 3.2 Update UI */
	
	LstComp = {"=", ">", "<", ">=", "<=", "Not Equal", "In", "Like", "Not Like"};
	IDComp = As List( Loc( LstComp, lstFilterSelected[3][1] ) )[1];
	
	UpdateWindow = New Window( "Update filter",
		Show Menu( 0 ),
		show toolbars( 0 ),
		V List Box(
			Outline Box( " Update filter",
				V List Box(
					H List Box(
						Lineup Box( N Col( 3 ), spacing( 10 ),
							Border Box( Left( 1 ), Text Box( "OLD" ) ),
							Text Box( Char( lstFilterSelected[3][1] ) ),
							Text Box( Char( lstFilterSelected[3][2] ) ),
							Border Box( Top( 4 ), Text Box( "NEW" ) ),
							V List Box(
								NewComp_cbx = Combo Box(
									LstComp,
									Comparator = NewComp_cbx << GetSelected();
									If( Comparator == "In",
										Newtxt_sep << Visibility( "Visible" );
										Newtxt_sep_edit << Visibility( "Visible" );
									,
										Newtxt_sep_edit << Visibility( "Collapse" );
										Newtxt_sep << Visibility( "Collapse" );
									);
								),
								Spacer Box( size( 10, 10 ) ),
								H List Box(
									Newtxt_sep = Text Box( "Edit list separator: " ),
									Spacer Box( size( 10, 10 ) ),
									Newtxt_sep_edit = Text Edit Box( "," )
								)
								
							),
							Border Box( Top( 4 ), NewValue_cbx = Text Edit Box( Char( lstFilterSelected[3][2] ) ) )
						)
					),
					H Center Box(
						Lineup Box( N Col( 3 ), spacing( 10 ),
							H Center Box(
								Button Box( "Update", 
								
									/* New filter */
									
									NewComp = NewComp_cbx << Get Selected();
									NewValue = NewValue_cbx << Get Text();
									
									If( And( NewComp == Char( lstFilterSelected[3][1] ), Char( NewValue ) == Char( lstFilterSelected[3][2] ) ),
										f_DialogError( "No update" )
									);
	
									If( NewValue == "",
										f_DialogError( "Missing value" )
									);
	
									If( And( Contains( CompNum, NewComp ), Is Missing( Num( NewValue ) ) ),
										f_DialogError( "Invalid value" )
									);
	
									/* Update Filters_AA */
	
									// [KEY: ID, correspond to the order of appearance in the list of filters] [VALUE: 1- Tagname with unit/descr (str) / 2- Tag Type (str) / 3- Filters (list)]
									Eval(
										Eval Expr(
											Filters_AA[IDFilterSelected] = {Expr( TagName_DescUnit ), Expr( strTagType ), {Expr( NewComp ),
											Expr( NewValue )}}
										)
									);
	
									/* Close Update filter window */

									UpdateWindow << close window();
									lstFiltersRegistered << Remove All;
									lstFilters = f_Convert2ListFilters( Filters_AA, Condition );
									lstFiltersRegistered << Append( lstFilters );
							
							
								)
							),
							Button Box( "Preview", 
								
								lstFilters = f_Convert2ListFilters( Filters_AA, Condition );
								
								/*  Tagtype */
									
								If( !(Contains( PreviewTags, strTagType )),
									f_DialogError( "Invalid tagtype for preview" )
								);
	
								outlinebox_Preview << Visibility( "Visible" );
	
								/*  Create temporary new Filters_AA */
	
								NewFilters_AA = Filters_AA;
								Remove From( NewFilters_AA, IDFilterSelected );
	
								/*  New Start date and New End date*/
						
								If( str.script_name == "Update/Refresh",
									NewEndPreview = EndTime << Get();
									meth = rdbox_method << Get();
									If( meth == 1,
										NewStartPreview = StartTime << Get();
										n_estimated_rows = (NewEndPreview - NewStartPreview) / NewPeriodNumValue_s;
									,
										NewStartPreview = NewEndPreview - (n_estimated_rows * NewPeriodNumValue_s)
									);
								,
									NewStartPreview = Start;
									NewEndPreview = End;
								);
								
								Eval(
									Eval Expr(
										strInfoExtractDates = "Between " || Format( Num( Expr( NewStartPreview ) ), "yyyy-mm-ddThh:mm:ss" ) || " /  "
										 || Format( Num( Expr( NewEndPreview ) ), "yyyy-mm-ddThh:mm:ss" )
									)
								);
								strInfoExtractDates = strInfoExtractDates || " AND " || Char( N Items( NewFilters_AA ) ) || " filter(s)";
								txtInfoPreview << Set Text( "Extract dates: " || strInfoExtractDates );
	
								/* Preview */
	
								lstPreviewValues = List();

									// Warn the user if there is too many distinct values to display
								Newn_estimated_rows = (NewEndPreview - NewStartPreview) / NewPeriodNumValue_s;
								f_Log( "INFO", "Potential rows per tag - " || Char( Newn_estimated_rows ), "PREVIEW" );
								If( Newn_estimated_rows > NRow_limit_preview, 
		
									win = New Window( "Warning",
										<<Modal,
										V List Box(
											Text Box(
												"There is " || Char( Newn_estimated_rows ) ||
												" potential rows per tag. Press OK if you want to continue."
											),
											Spacer Box( 15, 15 ),
											H List Box(
												Border Box( Left( 80 ),
													Lineup Box( N Col( 2 ), Button Box( "OK" ), Button Box( "Cancel", Throw() ) )
												)
											)
										)
									);
		
									// Stop preview if the user clicks on "Cancel" button
									If( win["button"] == -1,
										Throw()
									);	
				
								);
	
	
								NewEndPreview = f_CheckDates( NewStartPreview, NewEndPreview, NewPeriodNumValue_s, "None", ServerType );
								{NewStartPreviewFormat, NewEndPreviewFormat} = f_FormatDates( NewStartPreview, NewEndPreview, 0 );
	
								f_Log( "INFO", "Start date UTC (yyyy-mm-ddThh:mm:ss) - " || NewStartPreviewFormat, "PREVIEW" );
								f_Log( "INFO", "End date UTC (yyyy-mm-ddThh:mm:ss) - " || NewEndPreviewFormat, "PREVIEW" );
	
								__SQL_FILTERS = f_SQL_CREATE_ALL_FILTERS(
									NewStartPreviewFormat, NewEndPreviewFormat, NewFilters_AA, Condition, ServerType
								);
						
								dt_Preview = f_SQL_PREVIEW( TagName, NewStartPreviewFormat, NewEndPreviewFormat, __SQL_FILTERS, ServerType );
	
								Try(
									lst_ValuePreview = Column( dt_Preview, "VALUE" ) << get values(),
									Try( Close( dt_Preview, NoSave ) );
									f_DialogError( "No results" );
								);
									
								Close( dt_Preview, NoSave );
	
								If( !(Is List( lst_ValuePreview )), 
										// Convert in list of character values
									f_Log( "WARNING", "The values were in a numeric format. Converting them to character.", "PREVIEW" );
									lst_ValuePreview = As List( lst_ValuePreview );
									For Each( {value, index}, lst_ValuePreview, lst_ValuePreview[index] = Char( value ) );
								);
		
								Insert Into( lstPreviewValues, lst_ValuePreview );
	
								lstPreviewValues = f_RemoveDuplicates( lstPreviewValues );
	
								// Remove duplicates 
								f_Log( "INFO", "There is " || Char( N Items( lstPreviewValues ) ) || " distinct values.", "PREVIEW" );
	
								// Add them to preview UI
								lst_DistinctValues << Append( lstPreviewValues );
								txtbox_nbPreview << Set Text( " [ " || Char( N Items( lstPreviewValues ) ) || " ]" );
							
							
							
							),
							Button Box( "Cancel", UpdateWindow << close window() )
						)
					)
				)
			),
			outlinebox_Preview = Outline Box( "Preview",
				V List Box(
					Border Box( top( 10 ), Left( 10 ),
						V List Box(
							Spacer Box( Size( 10, 10 ) ),
							Text Box( Char( TagName_DescUnit ), <<SetFontSize( 9 ) ),
							Spacer Box( Size( 10, 10 ) ),
							txtInfoPreview = Text Box( " " ),
							Spacer Box( size( 10, 10 ) ),
							Lineup Box( N Col( 2 ),
								Text Box( "Please select new values", <<Set Font Style( "Bold" ) ),
								txtbox_nbPreview = Text Box( " " )
							)

						)
					),
					H List Box(
						V Center Box(
							Lineup Box( N Col( 1 ), Spacing( 5 ),
								bttn_OKPreview = Button Box( "Add", 
							
									/* Get filter value */
	
									Try( lstValues = lst_DistinctValues << Get Selected(), f_DialogError( "No filter selected" ) );
	
									f_Log(
										"INFO", "The user updates conditions with filter values - " || Concat Items( lstValues, " / " ), "PREVIEW"
									);
	
									For( i = 1, i <= N Items( lstValues ), i++,
										If( Is Missing( Num( lstValues[i] ) ),
											lstValues[i] = "'" || lstValues[i] || "'"
										)
									);
									ConcatLstValues = Concat Items( lstValues, "," );
									str_FilterConcat = TagName_DescUnit || " In " || ConcatLstValues;
	

									/* Add value */
									
									NewValue_cbx << Set Text( ConcatLstValues );

							
								), 

							)
						),
						Border Box( top( 10 ), Left( 10 ), bottom( 10 ), Right( 10 ), lst_DistinctValues = List Box( {}, <<Set Size( 290, 272 ) ) ),
						V Center Box(
							bttn_Sort = Button Box( "Sort",
								values = lst_DistinctValues << Get Items();
								Sort List Into( values );
								lst_DistinctValues << Remove All;
								lst_DistinctValues << Append( values );
							)
						)
					)
				)
			)
		)
	); // END UpdateWindow 
	
	// Cosmetics
	NewComp_cbx << Set( IDComp );
	If( lstFilterSelected[3][1] == "In",
		Newtxt_sep << Visibility( "Visible" );
		Newtxt_sep_edit << Visibility( "Visible" );
	,
		Newtxt_sep_edit << Visibility( "Collapse" );
		Newtxt_sep << Visibility( "Collapse" );
	);
	
	NewValue_cbx << Set Width( 300 );
	outlinebox_Preview << Visibility( "Collapse" );

									
	
	// Center the Update filter Window
	f_CenterWindow( UpdateWindow, WindowSize );


);


/*
    f_button.find_tags Function
    
    This function is associated with the "Find tag" button and is utilized across multiple scripts ("Main UI", "Add tags") to facilitate the search of new tags to add.
        
*/

f_button.find_tags = Function( {}, 


/****************************************************
*  I. SETTINGS
******************************************************/

	//Parameter for log
	section = "FIND TAGS";
	
/* 1.1. Tag and Description */

	StrTagName = txtbox_TagName << Get Text;
	StrTagDesc = txtbox_TagDesc << Get Text;
	
	f_Log( "INFO", "Tag name - " || StrTagName, section );
	f_Log( "INFO", "Tag description - " || StrTagDesc, section );
	
	
/* 1.2. Extraction information */
	
	f_SetUp4Extraction( ServerType );
	

/****************************************************
*  II. TAG SEARCH
******************************************************/


/* 2.1. Tag search */


	f_Log( "INFO", "START tags search.", section );
	dt_TagTable = f_SQL_FINDTAGS( StrTagName, StrTagDesc, ServerType );
	
	// Order elements alphabetically by tagnames
	dt_TagTable << Sort( By( :tagnames ), Replace Table, Order( Ascending ), Copy formula( 0 ) );
	
	// Create new column containing tagname (descr) [units]
	dt_TagTable << New Column( "tag_desc_units",
		"Character",
		Formula( :tagnames || " (" || :descriptions || ") [" || :units || "] {" || :type || "}" )
	);
	

/* 2.2. Update list of available tags */

	lstAvailableTags << Remove All;

		//list of tagname elements from extraction
	tag_NO_desc_units_list = Column( dt_TagTable, "tagnames" ) << Get Values;
		
		//list of tagnames_desc_units from extraction
	TagList_DescUnit = Column( dt_TagTable, "tag_desc_units" ) << Get Values;
	
	f_Log( "INFO", Char( N Items( TagList_DescUnit ) ) || " tags found.", section );
	f_Log( "INFO", "END tags search.", section );
		
	// Close the TagTable
	Close( dt_TagTable, nosave );
	
	// Update list box lstAvailableTags w
	lstAvailableTags << Append( TagList_DescUnit );
	lstAvailableTags << Set Tips( TagList_DescUnit );
	
	// Add info about number of available tags
	n_available_tags = N Items( TagList_DescUnit );
	If( n_available_tags == 0,
		txtbox_nbTags << Set Text( "" ),
		txtbox_nbTags << Set Text( " [ " || Char( n_available_tags ) || " ] >>> " )
	);
	
); // End EXPR_Find_Tags

